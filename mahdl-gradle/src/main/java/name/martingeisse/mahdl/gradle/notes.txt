
Differences in MaHDL vs. ESDK
--------------------------------------------------------------------------------

A MaHDL module has a name. It is possibly native, meaning that no code is generated at all.

Below the header, there are six differend kinds of language constructs that must be compiled to ESDK-style Java code:
- constants. Theses are compiled to public static final fields at the top. They are public since some of these may be
    part of a "contract" with the code that uses the module, but ESDK has no concept of marking them public.
- ports. We distinguish clock ports and non-clock (data) ports. For clock ports, we only support input ports at the
    moment.
- signals. We disallow local clock signals at the moment.
- registers.
- do-blocks. We distinguish clocked do-blocks and continuous do-blocks. Clocked do-blocks get grouped with the
    registers they drive (only one do-block can drive a register). Registers without a do-block driving them are
    currently not supported.
- module instances.

The generated class is subdivived into:
- fields part
- definition part (first half of the constructor)
- implementation part (second half of the constructor)
- accessors part (getters and setters)

We handle clock input ports by accepting RtlClockNetworks as constructor parameters (sorted alphabetically by their
name so the order is stable between rebuilds), storing it in a final field (in the fields section; storing happens
at the top of the constructor even before the definition part), and passing it to all clocked do-blocks that use it
as well as all module instances that use it (implementation part). See those sections below for details.

--- TODO implemented until here

This leaves the following MaHDL constructs:
- data ports
- data signals
- continuous do-blocks
- clocked do-blocks and their registers
- module instances

For all data ports and local signals, we create signal connectors (fields part; definition part), which means that the
signals already exist and can be used as sources before we set *their* sources. Registers work differently, and module
instances already create signal connectors for their own ports themselves. Data signals with an initializer will
have that initializer converted to an RtlSignal expression which is passed to the signal connector in the implementation
part.

Accessors part: A getter is defined for each output port, returning the signal connector. A setter is defined for each
input port, passing the argument to the setter of the signal connector. The connector itself is not replaced, which
is the whole point of it -- so we can use the signal even before the setter was called.

For each module instance, a field is created (fields part) and the module instance created (definition part). The
constructor only needs the RtlRealm (implicit first constructor parameter of all generated modules) and clocks.
For the latter, we scan the ports of the module instance for all clock ports (Which must be input ports), sort them
by name, then pass them. It is currently not possible to use anything beyond a simple reference to a clock input port
of the enclosing module here; if it were, we would have to refine the ordering (esp.: currently the order with
signal definitions is undefined, so other signals cannot be used; using data ouputs of other module instances is
especially tricks. Probably the only way to handle this would be to make the clock a settable field in ESDK like
data fields).

Note that after creating the module instances, their output ports are ready to use (since they are pre-created
signal connectors, too).

This leaves the following MaHDL constructs:
- assignments needed for data output ports
- assignments needed for data signals without initializers
- assignments needed for module instance data input ports
- continuous do-blocks (containing all these assignments)
- clocked do-blocks and their registers

For the signal assignments, all three kinds of assignment targets can be made through setters (signal connectors or
module instance setters). We just scan through all continuous do-blocks. For each do-block, we determine the signals
assigned to, then convert the result for each signal from statement sequence to expression.

Finally, for each clocked do-block and associated set of registers, we create a field for each register (fields part).
We don't create fields for the do-blocks themselves because we don't need them (they cannot be targeted by any MaHDL
constructors). We create each clocked do-block and its register objects (definitions part) using the specified
clock. We then convert statements directly (implementation part). For statement sub-sequences, we a local
variable in the constructor with an assigned name for each sub-sequence, and possibly helper objects with assigned
names for the statements themselves. We have to do this because the implicit structure from nesting the sub-sequences
in MaHDL is lost in the ESDK constructor -- everything happens on the same nesting level there.
